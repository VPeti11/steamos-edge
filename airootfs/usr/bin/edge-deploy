#!bin/bash
set -euo pipefail
IFS=$'\n\t'

ask() {
  local prompt="$1" default="$2" resp
  if [[ -n "$default" ]]; then
    read -rp "$prompt [$default]: " resp
    resp="${resp:-$default}"
  else
    read -rp "$prompt: " resp
  fi
  printf '%s' "$resp"
}
ask_yes() {
  local prompt="$1" yn
  while true; do
    read -rp "$prompt (yes/no): " yn
    case "$yn" in yes) return 0 ;; no) return 1 ;; *) echo "Type yes or no." ;; esac
  done
}
err() { printf 'ERROR: %s\n' "$*" >&2; }

REQUIRED=(parted lsblk dd mkfs.ext4 stat blockdev udevadm partprobe)
for c in "${REQUIRED[@]}"; do
  command -v "$c" >/dev/null 2>&1 || { err "missing $c"; exit 1; }
done

if [[ $EUID -ne 0 ]]; then err "run as root"; exit 1; fi

while true; do
  SRC="$(ask "Source (ISO file or block device)" "")"
  [[ -n "$SRC" ]] || { echo "enter path"; continue; }
  [[ -e "$SRC" ]] || { echo "not found"; continue; }
  if ask_yes "Use $SRC?"; then break; fi
done

while true; do
  DEST_RAW="$(ask "Destination disk (whole-disk device, e.g. /dev/sdb or /dev/nvme0n1)" "")"
  [[ -n "$DEST_RAW" ]] || { echo "enter device"; continue; }
  if [[ "$DEST_RAW" =~ [0-9]$ || "$DEST_RAW" =~ p[0-9]+$ ]]; then
    parent="$(lsblk -ndo pkname "$DEST_RAW" 2>/dev/null || true)"
    if [[ -n "$parent" ]]; then
      parent="/dev/$parent"
      if ask_yes "Operate on parent disk $parent (overwrite partition table)?"; then DEST_DISK="$parent"; else
        if ask_yes "Operate on provided $DEST_RAW instead?"; then DEST_DISK="$DEST_RAW"; else continue; fi
      fi
    else
      if ask_yes "Operate on provided $DEST_RAW?"; then DEST_DISK="$DEST_RAW"; else continue; fi
    fi
  else
    DEST_DISK="$DEST_RAW"
  fi
  [[ -b "$DEST_DISK" || -e "$DEST_DISK" ]] || { echo "device not found"; continue; }
  lsblk "$DEST_DISK"
  if ask_yes "I will overwrite the partition table on $DEST_DISK. Proceed?"; then break; fi
done

if ask_yes "Enable shell tracing (verbose)?"; then set -x; fi

get_size_bytes() {
  local p="$1"
  if [[ -b "$p" ]]; then blockdev --getsize64 "$p"; else stat -c%s "$p"; fi
}
SRC_BYTES="$(get_size_bytes "$SRC")"
if [[ -z "$SRC_BYTES" || "$SRC_BYTES" -le 0 ]]; then err "cannot determine source size"; exit 1; fi
MIB=1048576
SRC_MiB=$(( (SRC_BYTES + MIB - 1) / MIB ))

PADDING_MiB_DEF=0
PADDING_MiB_STR="$(ask "Padding in MiB to add to partition1" "$PADDING_MiB_DEF")"
if [[ "$PADDING_MiB_STR" =~ ^[0-9]+$ ]]; then PADDING_MiB="$PADDING_MiB_STR"; else PADDING_MiB=0; fi
PART1_SIZE_MiB=$(( SRC_MiB + PADDING_MiB ))

DISK_BYTES="$(blockdev --getsize64 "$DEST_DISK")"
DISK_MiB=$(( DISK_BYTES / MIB ))
if (( DISK_MiB <= PART1_SIZE_MiB + 1 )); then err "destination too small"; exit 1; fi

LABEL_MODE="$(ask "Partition table (auto/msdos/gpt)" "auto")"
if [[ "$LABEL_MODE" == "auto" ]]; then
  if ask_yes "Target machine BIOS-only? (if unsure answer yes)"; then LABEL="msdos"; else LABEL="gpt"; fi
else
  LABEL="$LABEL_MODE"
fi

BIOS_GRUB_MiB=0
if [[ "$LABEL" == "gpt" ]]; then
  if ask_yes "Create small bios_grub partition (no bootloader will be installed)?"; then
    BIOS_GRUB_MiB_STR="$(ask "bios_grub size in MiB" "2")"
    if [[ "$BIOS_GRUB_MiB_STR" =~ ^[0-9]+$ ]]; then BIOS_GRUB_MiB="$BIOS_GRUB_MiB_STR"; else BIOS_GRUB_MiB=2; fi
  fi
fi

if [[ "$LABEL" == "gpt" && "$BIOS_GRUB_MiB" -gt 0 ]]; then
  BIOS_START=1
  BIOS_END=$(( BIOS_START + BIOS_GRUB_MiB ))
  PART1_START=$(( BIOS_END ))
else
  PART1_START=1
fi
PART1_END=$(( PART1_START + PART1_SIZE_MiB ))

printf "Plan: part1 %d..%d MiB (%d MiB). part2 = remainder.\n" "$PART1_START" "$PART1_END" "$PART1_SIZE_MiB"
if ! ask_yes "Proceed with this plan and overwrite $DEST_DISK?"; then err "aborted"; exit 1; fi

if [[ "$LABEL" == "msdos" ]]; then
  parted --script "$DEST_DISK" mklabel msdos \
    mkpart primary "${PART1_START}MiB" "${PART1_END}MiB" \
    mkpart primary "${PART1_END}MiB" 100% >/dev/null
  parted --script "$DEST_DISK" set 1 boot on >/dev/null
elif [[ "$LABEL" == "gpt" ]]; then
  if (( BIOS_GRUB_MiB > 0 )); then
    parted --script "$DEST_DISK" mklabel gpt \
      mkpart primary "${BIOS_START}MiB" "${BIOS_END}MiB" \
      mkpart primary "${PART1_START}MiB" "${PART1_END}MiB" \
      mkpart primary "${PART1_END}MiB" 100% >/dev/null
    parted --script "$DEST_DISK" set 1 bios_grub on >/dev/null
  else
    parted --script "$DEST_DISK" mklabel gpt \
      mkpart primary "${PART1_START}MiB" "${PART1_END}MiB" \
      mkpart primary "${PART1_END}MiB" 100% >/dev/null
  fi
else
  err "unsupported label"; exit 1
fi

partprobe "$DEST_DISK" || true
udevadm settle || true
sleep 1

disk_base=$(basename "$DEST_DISK")
if [[ "$disk_base" == nvme* || "$disk_base" == mmcblk* ]]; then
  if [[ "$LABEL" == "gpt" && "$BIOS_GRUB_MiB" -gt 0 ]]; then
    PART1="${DEST_DISK}p2"; PART2="${DEST_DISK}p3"
  else
    PART1="${DEST_DISK}p1"; PART2="${DEST_DISK}p2"
  fi
else
  if [[ "$LABEL" == "gpt" && "$BIOS_GRUB_MiB" -gt 0 ]]; then
    PART1="${DEST_DISK}2"; PART2="${DEST_DISK}3"
  else
    PART1="${DEST_DISK}1"; PART2="${DEST_DISK}2"
  fi
fi

for i in {1..15}; do
  [[ -b "$PART1" && -b "$PART2" ]] && break
  sleep 1
done
[[ -b "$PART1" && -b "$PART2" ]] || { err "partitions not found"; exit 1; }

part1_bytes="$(blockdev --getsize64 "$PART1")"
if (( part1_bytes < SRC_BYTES )); then err "partition1 smaller than source"; exit 1; fi

printf "About to dd %s -> %s\n" "$SRC" "$PART1"
if ! ask_yes "Proceed with dd?"; then err "dd cancelled"; exit 1; fi
dd if="$SRC" of="$PART1" bs=4M status=progress conv=fsync
sync

mkfs.ext4 -F -L arch-bootstrap "$PART2"

printf "Done. Image written to %s. %s formatted ext4.\n" "$PART1" "$PART2"
